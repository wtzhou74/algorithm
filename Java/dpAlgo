！！！dp[]/dp[][] 初始化的时候有的时候看是不是需要设置为  fill(dp, -1),有时候选用默认值 0是不对的，因为 0 本身可以是结果

！！！每一个dp值就是一个子问题的结果  ==> 注意dp的定义，1/2维，以及初始化， recursive的话注意返回值
	===> 定义子问题  dp ==> NumberOfDiceRollsWithTargetSum.java
	

- （最小/大步实现目的） ==> 每一步有多个选择，不同选择产生不同的结果（cost）, 计算到达target后的最小cost 
	- 找出到达某一步的options, 比如右移，跳2步等， ==> 下一步的最优就是上面各个options的最优，之前各个options是已知的
	- relation往往是  dp[i] + 新值， 或者 min/max(多个DP值)
	===> MinCostClimbingStairs.java // 一维
	===> MinimumPathSum.java  // 二维 ==> 按cell[i][j]走，思路与1维一样
	===> CoinChange.java // 每一步都可以从这里面取  ==> 这里设置的 dp[] 其基数是 amount, 
									====> 子问题的结果是 1， 2， ... amount分别对应的最少次数硬币选择
							

- (所有不同distinct方式到达target)
	- 就是把不同选择的dp（不同策略下对应的子问题结果）值相加 （dp是子问题的解，那这里dp[i]就是当前 i 下的distinct ways）
	- relation往往是 不同选择下 对应多个dp值的和 ， 即类似 dp[i] + dp[i - 1]
	====> ClimbStairs.java // 1维
	====> UniquePaths.java // 2维
	====> FrogJump.java // 后面的选择依赖前面， i = idx + 1 (不仅仅子问题前后依赖)
	
	- 对有的题目，上面的方式可以 repeat, 那无非就是外面再加一层 for，用于重复处理而已
	====> NumberOfDiceRollsWithTargetSum.java  // 有多个dice  （！！！dp的定义）
	
	
	
- 按区间递归，即子问题是 [left, right]区间的结果   ===> 左边界（左子集）结果 + 第K个元素（k在[l, r]之间） + 右边界（右子集）结果
	- ！！！一定要分解正确区间
	====> MinimumCostTreeFromLeafValues.java
	====> EncodeStringWithShortestLength.java // 分左右两段
	
	

- Strings问题 ==> 给两个字符串，返回某个结果， 比如最长subsequence  ==> 一般都能在 O（N^2）时间内完成
	 
	- 子问题一般是， 对s1的子串，s2的子串， 得出要求的结果， 比如： s1: "abcde", s2: "bcd" ==> ([a],[b]), ([abc],[bc]) 等
					// 一共会有 s1.len * s2.len个子问题		====> 2维
	- 在解决子问题中， 对每个结果，可以有 2 中选择，选上/不选
		==> c1==c2 ? 长度+1 ： max(s1移动，s2移动)
	====> LongestCommonSubsequence.java   ===> 每个字符 是/不是 最终subsequence中的字符
	====> InterleavingString.java
	====> LongestPalindromicSubsequence.java
	====> JumpGame.java (里面一层for的跳出条件是  j < i, 因为我们要判断 （j, i）的情况)
	
	
	==> 对给定1个字符串的， 其dp关系往往是从某个字符到另一个字符之间（子串） ==> 2维  ==> O(N^2)
	- 要注意的是  ==> 针对的是子串 ==> 子串长度  ==> 所以第一层for 就是针对 l/span [1,n]
								===> 第二层开始，在该子串内 [0,n-l]，根据dp关系求解子问题
	====> LongestPalindromicSubstring.java
	====> WordBreak.java; WordBreakII.java （用 dp[] - bottom-up对需要列出所有值会TLE，适合用于判读true/false,这样就可以提前break掉）
	
	

- Decision-making 问题   ==> 给一系列值，根据取/不取 current value 达到某个结果    
						==> 在current value下， 取/不取，做/不做 状态   ===> 也是个状态机/FSM
	====> HouseRobber.java  // 前后两个状态在 做/不做 间选的时候 有时候是有条件的
							//  f(r) = Math.max(f(r-2) + currVal, f(r-1));//第一种decsion取currVal, 另一种decision不取currVal
	====> BestTimetoBuyandSell.java  // 对DP这个不是很好的例子，但是个 Greedy算法的好例子
									// 不停求“局部最优”，得出最终的最优，但实际也是DP的思路，所以其两者往往可以互换
	====> !!!BestTimeToBuyAndSellStockWithCoolDown.java	//每天都有3状态可选，dp[n][3], 
					//前后两天状态是存在联系的，	即状态之间转换关系  ==> FSM		
		===> 最多K次交易的问题： ！！！在求解profit, 后一次的profit是要参考前一次的profit的， 否则会重复计算，因为这是题意不允许的
		===> 一定要先理清关系/状态转换关系  ==> BestTimeToBuyAndSellStockWithCoolDown.java
		===> 或者画出价格变化图 ==> BestTimeToBuyAndSellStockII.java
	====> BestTimetoBuyandSellStockIII.java; BestTimetoBuyandSellStockIV.java