- 找满足条件的最长sub-array ==> Sliding Window
- Find the longest subarray with at most K zeros. ===> MaxConsecutiveOnesII.java

===> Explanation (对于一般情况， 尤其是size不固定)
	- For each A[j], try to find the longest subarray.
	- If A[i] ~ A[j] has zeros <= K, we continue to increment j.
	- If A[i] ~ A[j] has zeros > K, we increment i.
	
====> a这里有时候可优化的是 - 找有效的删除idx(会影响Windows Size 长度的)  ===> LongestSubstringWithAtMostTwoDistinctCharacters.java

====> size固定， 从指定window size开始，而不是 i = j = 0;   ====> PermutationInString.java
	
---------------------- GREAT Example
MaxConsecutiveOnesII.java
LongestSubstringWithAtMostTwoDistinctCharacters.java
PermutationInString.java