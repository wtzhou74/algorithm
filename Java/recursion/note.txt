递归==>重复 ==> 确定重复的单元并实现  ===> OutputContestMatches.java

A recursive function should have the following properties so that it does not result in an infinite loop:

	- A simple BASE CASES (or cases) — a terminating scenario that does not use recursion to produce an answer.
	- A set of rules, also known as recurrence relation that reduces all other cases towards the base case.
	
 Not every problem can be solved with recursion, due to the time or space constraints

CALL ITSELF ITERATIVELY

TWO IMPORTANT THINGS that one needs to figure out before implementing a recursive function:

	- RECURRENCE RELATION: the relationship between the result of a problem and the result of its subproblems.
	- BASE CASE: the case where one can compute the answer directly without any further recursion calls. Sometimes, 
		the base cases are also called bottom cases, since they are often the cases where the problem has been reduced 
		to the minimal scale, i.e. the bottom, if we consider that dividing the problem into subproblems is in a top-down manner.
	https://leetcode.com/explore/learn/card/recursion-i/251/scenario-i-recurrence-relation/1644/

https://leetcode.com/explore/learn/card/recursion-i/253/conclusion/1650/	
WHEN IN DOUBT:
	- write down the RECURRENCE RELATIONSHIP.
WHENEVER POSSIBLE:
	- apply MEMOIZATION, e.g. Fibonacci numbers
WHEN STACK OVERFLOWS:
	- TAIL RECURSION might come to help. => could optimize the SPACE complexity of the algorithm, by eliminating the stack overhead incurred by recursion.
					- it is easy to read and understand, compared to non-tail-recursion. Because there is no post-call dependency in tail 
					  recursion (i.e. the recursive call is the final action in the function), unlike non-tail-recursion.

RECURSION + MEMOIZATION
	
Pascal's Triangle:
	- RECURRENCE RELATION: f(i,j)=f(i−1,j−1)+f(i−1,j) => to calculation each cell'value
	- DEFINE THE FUNCTION
	
1. SwapPairs (SWAP NODEs in Pairs)
- pay close attention to PRE, CUR, NXT nodes when you break the linked list

2. PascalTriangle
- optimize your algorithm to use only O(k) extra space? => RESET VALUE IN PLACE IN LIST

3. ReverseLinkedList !!!!!!!!!!
- 1->2->3->null => null <- 1<-2<-3 => just update previous
- Assume from node nk+1 to nm had been reversed and you are at node nk. n1 → …
    → nk-1 → Nk → nk+1 ← … ← nm We want nk+1’s next node to point to nk. So,
	nk.next.next = nk; !!!!!!!! Thoughts to APPLY RECURSIVE SOLUTION
	

4. FibonacciNumber => MEMOIZATION / cache => HashMap

5. ClimbingStairs => Brute force => TLE => Memoization

6. MyPower(x , n) : NOTE: 1) long N=n to avoid overflow; 2) if n < 0; then do mypower(1/x, -n), don't do 1 / mypower(x, -n), 0 will return for some cases.

7. MergeTwoLists.java
	- Pay close attention to the LIST-> POINTERs
	
8. KthSymbolInGrammar.java
	- Finding the RULE
	- Define the RECURRENCE RELATION !!!!!!
	
	
---
Base
divide(nums, start - 1);
int[] res = Arrays.copyOfRange(nums, start, start + 1);
// The second statement will be executed only when BASE meeted, and then start from base and then go back.
	
	