Building a Trie Time: O(m * n); m is the number of words, and n is the average length of the word
Insert/Search:  O(m), the maximum string length. The Penalty is on Trie Storage requirements.

Trie, also called prefix tree, is a special form of a Nary TREE. It is used to STORE STRINGs.
Each node represents a STRING (a PREFIX)
ROOT is associated with the EMTPY STRING
ALL the DECENDANTs of a node have a COMMON PREFIX of the string associated with that node. That is why Trie is also called PREFIX TREE.

USING ARRAY to STORE CHILDREN NODES, e.g. a to z, new char[26]; and using c - 'a' as the INDEX to find the corresponding child node 
	in the array, e.g. TrieNode[] children = new TrieNode[26];.
USING HASHMAP to STORE CHILDREN NODES, might be a little SLOWER, but it SAVEs SOME SPACE since we ONLY 
	STORE the children nodes WE NEED, e.g. Map<Character, TrieNode> children;

BUILDING A TRIE is actually to CALL THE INSERTION FUNCTION several times. But REMEMBER to INITIALIZE A ROOT NODE before inserting the strings.
- creating a Trie NODE (val, children, isword)
- INITIALZING a Trie (root = new TrieNode('')) => root is associated with an EMPTY STRING
- Traversing Trie => starting from root


STRINGs => FINDing => Trie

	Step 1: Initialize TrieNode
	Step 2: new ROOT with EMPTY string/char
	Step 3: Starting from ROOT, then insert/search

Recursively traverse each child [LEVEL-TRAVERSE] => AddAndSeachWord.java

----
public class TrieNode {

	Map<Character, TrieNode> children;
	char val; // can be other data type, e.g. MapSumPairs
	boolean isWord;
	
	public TrieNode(char val) {
		this.val = val;
		this.children = new HashMap<>();
		this.isWord = false;
	}
}

// TODO: PalindromPairs.java in Trie Solution