TWO-POINTER Technique (Array, LinkedList, etc.):
Note: The proper speed for two pointers
	1. Two pointers starts at different position: one starts at the beginning while another starts at the end.
	2. Two pointers are moved at different speed: one is FASTER while another one might be SLOWER.
	
Definition for a binary tree node
public class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;
	
	TreeNode(int x) {
		val = x;
	}
}



/////////reivew
PerfectSquare
	Number of islands => recursion/DFS, BFS
	Open Lock => BFS
	PerfectSquare
	Target num / Partition Equal Subset Sum => Dynamic Programming
	
TRACE BACK / BACKTRACK


Memoization (CACHE) !!!!!!! for RECURSIVE SOlution for DUPLICATE CALCULATION, 
	hence to reach the goal by REDUCING TIME IN EXCHANGE for some ADDITIONAL SPACE (cache).
	-> https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1495/
	-> CLIMBING STAIRS.java; UniqueBinarySearchTreesII.java

Dynamic Problem:
	- ClimbingStairs.java
	
Time Complexity for RECURSION ALGORITHMS (https://leetcode.com/explore/learn/card/recursion-i/256/complexity-analysis/1669/):
	- Given a recursion algorithm, its time complexity O(T) is typically the product of THE NUMBER OF RECURSION INVOVATIONS (denoted as R) 
	  and the TIME COMPLEXITY OF CALCULATION  (denoted as O(s)) that incurs along with each recursion call:

	O(T)=R * O(s)
	
Space Complexity for RECURSION ALGORITHMS (https://leetcode.com/explore/learn/card/recursion-i/256/complexity-analysis/1671/)
	- There are mainly two parts of the space consumption that one should bear in mind when calculating the space complexity
	  of a recursive algorithm: RECURSION RELATED and NON-RECURSION RELATED space.
	  
	 - Tail Recursion
	 
if signed integer n is [−2**31, 2**31 − 1]; then n can be -2**31, then -n will overflows

For ARRAY, LinkedList => pay close attention to the INDEX, => sort_array.java

FIND RELATION => PAY CLOSE ATTENTION TO THE GRAPH/PIC etc. => TheSkylineProblem.java



--
BINARY SEARCH TREE:
- The LEFT subtree of a node contains only nodes with keys LESS than the node's key (IF EQUAL, THEN NOT).
- The RIGHT subtree of a node contains only nodes with keys GREATER than the node's key (IF EQUAL, THEN NOT).
- The LEFT and RIGHT subtree each must also be a binary search tree. => RECURSIVE (in nature) => ValidateBST.java
- EMPTY or a SINGLE node is a valid BST itself.

- INORDER of BST's elements are in ASCENDING order  (SORT <=> BST)

-2D MATRIX => row index /, col index % for wrap around => flatten 2D to 1D => https://leetcode.com/problems/search-a-2d-matrix-ii/discuss/66140/my-concise-omn-java-solution

