DP ==
	1) RECURSION + MEMO
	2) DP array


DP: RECURSION + MEMOIZATION  ~~ "careful brute force"
====> MEMOIZATION of TWO-DIMENSION array ==> UniquePaths.java

Second explanation:  ==> maintain a DP array.
	https://www.cnblogs.com/grandyang/p/4383632.html
	=> The DP array contains all SOLUTION （DP[i] ==> the answer of SUBPROBLEM）
	=> Found the relation between dp[i] and dp[i+1]    ===> LongestPalindromicSubstring.java
	

recursion的过程即是找solution的一个完整过程（解决一个个subproblem）  ==> JumpGame.java
Each DP result EQUALs a SOLUTION of subproblem and EQUALs one RECURSION

也是一个计算dp数组的过程，这个dp数组的元素都要计算  ====> WildcardMatch.java


The MOST IMPORTANT work for DP is to find the RALTION between dp[i], dp[i-1] or dp[i-2]
后续的子问题答案 “依赖于” 前面子问题的结果  => Relation  (用已知的dp值去更新/求解未知的)    ===> BurstBallons.java
For M X n matrix, int[][] dp = new int[m][n];

DP array can have multiple definitions, 
	e.g. int[], int[][], 
	boolean[][] (dp table): PalindromePartitioning.java(!!!!!!)
	
	
	
	
